\documentclass[a4paper,12pt]{article}

\usepackage[german]{babel}
\usepackage{blindtext}
\usepackage{charter}
\usepackage{index}
\usepackage{csquotes}
\usepackage{dirtytalk}

\begin{document}


\title{\Large{\textbf{Eine Analyse von Programmiersprachen gemäss spätem Wittgenstein}}}
\author{Lu Maltsis \\
Weinbergstrasse 105 \\
8006, Zürich \\
lu.maltsis@gmail.com \\
\textit{Eingereicht beim MNG, Rämibühl}
}
\date{Eingereicht am xx.xx.xxxx \\
\vspace{10mm}
Betreuung durch Christian Villiger}
\maketitle
\newpage

\setcounter{section}{-1}
\tableofcontents{}

\section{Einführung}
Das Informationszeitalter hat dank des Computers unsere Gesellschaft umgewälzt. Es wird immer mehr automatisiert und informiert. Und im Kern des ganzen stehen die Programmiersprachen. Dieses neuartige Phänomen besitzt dabei gerade den Namen der Sprachen. Was hat es damit auf sich? Wieso besitzen diese Wunderkinder der Neuzeit den Namen des fundamentalen menschlichen Konzept der Sprache? \\
Bei dieser Untersuchung soll uns der Philosoph Ludwig Wittgenstein behilflich sein. Wittgenstein hat sich fundamentale Gedanken über natürliche Sprachen gemacht. Inwiefern kann man anhand von Wittgenstein Programmiersprachen mit natürlichen Sprachen vergleichen?


\section{Wittgensteins Sprachphilosophie}

\subsection{Die Unterscheidung zwischen Frühem und Spätem Wittgenstein}

Während des Ersten Weltkriegs schrieb Ludwig Wittgenstein sein erstes Hauptwerk: Die \enquote{Logisch-philosophische Abhandlung}, Englisch: \enquote{Tractatus logico-philosophicus} (TLP)\footnote{Wittgenstein 1921: 2} Hier werden allgemeine Sachverhalte (TLP: §2) als Konstrukte von Gegenständen (TLP: §2.1) bezeichnet. Die Sprache habe dann die Aufgabe diesen Gegenständen Namen zu geben (TLP: §3.22). Diese Philosophie wird als \enquote{früher Wittgenstein} bezeichnet. Der \enquote{späte Wittgenstein} widerspricht seinem Vorgänger explizit:
\begin{displayquote}
\enquote{[...] musste ich schwere Irrtümer in dem erkennen, was ich in jenem ersten Buche niedergelegt habe.}\footnote{Wittgenstein 1953: 4}
\end{displayquote}
In den \enquote{Philosophischen Untersuchungen} (PU), dem Hauptwerk des späten Wittgensteins wird unter anderem die Bedeutung der Sprache mithilfe von Aphorismen erforscht. 
\begin{displayquote}
\enquote{[...] Jedes Wort hat eine Bedeutung. Diese Bedeutung ist dem Wort zugeordnet. Sie ist der Gegenstand, für welchen das Wort steht.} \hspace{1mm} (PU: §1)
\end{displayquote}
Das ist was von Wittgenstein als \enquote{Wurzel der Idee der Sprache} (PU: §1) bezeichnet wird. So ist die Sprache nichts weiter als eine Ansammlung von Regeln, wie man Gegenstände benennt. Ein Ball ist ein rundes handliches Objekt, ein Haus ist eine feste Unterkunft\footnote{Definitionen zum Zweck der Darstellung stark vereinfacht}. Doch wer bestimmt eigentlich, welche Regel gilt?


\subsection{Wittgensteins Untersuchung von Regeln}
Wie kann eine grammatische Regel (oder Regeln im allgemeinen) das Handeln festlegen? So ist doch jedes Regelfolgen mit einer Deutung der Regel verbunden. (PU: §198) \\
Findet man zum Beispiel einen Wegweiser vor, so wäre eine mögliche Deutung \enquote{Wenn Sie das auf dem Wegweiser angegeben Ziel erreichen wollen, dann können sie es am besten in Pfeilrichtung erreichen.} Doch eine entgegengesetzte Deutung wäre genauso möglich: \enquote{Wenn Sie das auf dem Wegweiser angegebene Ziel erreichen wollen, dann können Sie es am besten entgegen der Pfeilrichtung erreichen}. Würde man Regeln festlegen wie eine solcher Wegweiser zu deuten sei, müsste man diese Regeln auch wieder erklären müssen etc. Es enstünde ein infiniter Regress. \footnote{Albert 2008: 35} Demnach muss etwas anderes geben, was bestimmt wie wir eine Regel zu deuten haben.

\begin{displayquote}
\enquote{Einer Regel folgen, eine Mitteilung machen, einen Befehl geben, eine Schachpartie spielen sind Gepßogenbeiten (Gebräuche, Institutionen).} (PU: §199)
\end{displayquote}


\subsection{Der Gebrauch der Sprache in Sprachspielen}
\enquote{Bedeutung ist Gebrauch} ist der Slogan dieser neuen Sprachphilosophie.(PU: §43) Einzelne Worte korrespondieren also nicht mit einem objektiven Sachverhalt in der Welt, sondern sind rein dadurch definiert, wie sie verwendet werden. Der Gebrauch der Sprache wird hierbei als \enquote{Sprachspiel} bezeichnet. (PU: §7)

\begin{displayquote}
\enquote{Das Wort 'Sprachspiel' soll hier hervorheben, daß das Sprechen
der Sprache ein Teil ist einer Tätigkeit, oder einer Lebensform. [...]
Es ist interessant, die Mannigfaltigkeit der Werkzeuge der Sprache
und ihrer Verwendungsweisen, die Mannigfaltigkeit der Wort- und
Satzarten, mit dem zu vergleichen, was Logiker über den Bau der
Sprache gesagt haben. (Und auch der Verfasser der Logisch-Philosophischen Abhandlung. ) \textit{(sic!)}} (PU: §23)
\end{displayquote}

Man kann sich dies mit einer Analogie zum Fussball vorstellen: Es kann durch eine Reihe an Regeln definiert werden. z.B. Geht der Ball ins Tor, kriegt die andere Mannschaft einen Punkt, Stürmer dürfen den Ball nicht mit den Händen berühren etc. Das Spiel funktioniert nur solange beide Mannschaften sich an die gleichen Regeln halten. Doch warum genau diese Regeln? \\ Man man macht es eben so, es ist eine Gepflogenheit. Das bedeutet nicht, dass die Regeln nicht einen praktischen Wert haben, doch lassen sie sich nicht auf wenig Axiome\footnote{Als Axiom bezeichne ich hier eine grundlegende Regel oder Logik, wie etwas aufgebaut ist. z.B. besitzt die Mathematik eine Vielzahl von Axiomen, von welcher all die anderen Regeln abgeleitet werden.} hinunterbrechen oder Empirisch herleiten.



\section{Programmiersprachen}
\subsection{Die Turing Maschine}
Die Turing Maschine ist eine theoretisches Konzept eines sehr einfachen Computers: Sie liest ein unendliches Band an leeren Quadraten ein (Input) und schreibt auf dieses eine gewisse Abfolge an Zeichen (Output).\footnote{Charles 2008: 79} Dies tut sie nach folgendem Prinzip: Sie besitzt verschiedene Konfigurationen $\alpha, \beta, \gamma, \delta$ etc. Jeder Zustand ist mindestens einer Instruktion so wie einem Endzustand verbunden. Jene Instruktionen ermöglichen die Interaktion mit dem leeren Band. 
\begin{displayquote}
\enquote{[...] \enquote{R} means \enquote{the machine moves
so that it scans the square immediately on the right of the one it was
scanning previously}. Similarly for \enquote{L}. \enquote{E} means \enquote{the scanned
symbol is erased} and \enquote{P} stands for \enquote{prints}.}\footnote{Turing 1937: Sektion 3} \footnote{Deutsche Übersetzung: \enquote{R} bedeutet \enquote{die Maschine geht eins nach rechts und scannt das Quadrat rechts von welchen, welches gerade zuvor gescannt hat}. \enquote{L} funktioniert auf die gleiche Weise. \enquote{E} bedeutet \enquote{das gerade gescannte Symbol wird gelöscht} und \enquote{P} bedeutet \enquote{die Maschine schreibt das dazugegebene Symbol}}
\end{displayquote}
Jetzt braucht die Maschine noch eine Reihe an Regeln:\footnote{Turing 1937: Sektion 3, Ich habe das dort aufgezeigte Beispiel vereinfacht}
\begin{itemize}
    \item $\alpha$ bedeutet P0, dann R mit dem Endzustand $\beta$
    \item $\beta$ bedeutet P1, dann R mit dem Endzustand $\alpha$
\end{itemize}
Beginnen wir nun mit dem Startzustand $\alpha$ wird das Programm die Abfolge $$01010101...$$ auf das Unendliche Band schreiben. Alan Turing, Erfinder der Turing Maschine, hat nun bewiesen, dass diese Art von Maschine jede berechenbare Abfolge aufschreiben kann.\footnote{Turing 1937: Sektion 2}

\subsection{Compiler}
Schlussendlich muss alles, was auf einem physischen Computer laufen soll, diesem in physikalischen Anweisungen gefüttert werden. Die Turing Maschine zeigt, wie solche Anweisungen aussehen, doch kann dies schnell mühsam bei komplexeren Programmen werden. Der Maschinencode, in welchen man nämlich schrieb, ist ein unleserlichen Fluss an Einsen und Nullen. Die Lösung: Der Compiler. \\
Ein Compiler ist ein Computerprogramm, welches eine Sprache in eine andere übersetzt.\footnote{Aho 2007: 1, Viele Definitionen engen das Ganze ein auf die Übersetzung einer Programmiersprache in Maschinencode, um Verwechslungen mit natürlichen Sprachen zu vermeiden. Doch gibt es auch Compiler, welche sich ausserhalb dieser vereinfachten Definition bewegen. (z.B. Stephens 2006, 26 zeigt einen Compiler, welcher von C++ zu C Code kompiliert und weltweit im Gebrauch ist.)} Die Grundidee dahinter ist die Folgende: Man gibt den Anweisungen im Binärcode klare Namen (e.g. \enquote{int} für eine Integerzahl) und lässt den Compiler diese in für den Computer lesbare Anwesiungen umschreiben. So kann z.B. die Instruktion der Zahlenfolge $01010101...$ wie folgt umgeschrieben werden: 
$$ while (True) \{ print(0); print(1);\} $$

\subsection{Moderne Programmiersprachen}
Der Kern einer jeden modernen Programmiersprache ist ein solcher Compiler. So auch zum Beispiel \enquote{Python}\footnote{Python benutzt in Wirklichkeit einen \textit{Interpreter} doch sind diese beiden für unsere Zwecke funktionell identisch.} Python wird in dieser Facharbeit als konkretes Beispiel genannt, doch, was für Python gilt, gilt für einen Grossteil aller Programmiersprachen.\\
Ein wichtiger Teil von Programmiersprachen ist hierbei die Zugänglichkeit. Nicht nur kann jeder Python downloaden, sondern auch den Quellcode, also wie Python den Code in Anweisungen für den Computer übersetzt, sich anschauen.\footnote{Python Software Foundation 2019a} Wäre ich nun zum Beispiel darüber unglücklich, dass Pythons Funktion zur Ausgabe \enquote{print} heisst, könnte ich deren Namen im Quellcode zu \enquote{outprint} umbennenen. Ich habe gerade meine eigene Programmiersprache geschaffen und nenne sie z.B. \enquote{Pythan}. Wen ich wollte könnte ich diese nun veröffentlichen und verbreiten.



\section{Gedanken über den fundamentalen Aufbau von Programmiersprachen und natürlichen Sprachen}
\subsection{Computergespräche}
Wenn wir uns einen Computer nun als Gesprächspartner vorstellen und wollten mit diesem sprechen, so müssten wir zuerst einmal eine Programmiersprache lernen. Genauso wie man wenn mit Annika, welche Italienisch, Deutsch und Englisch verstehen kann, sprechen will, einer ihrer Sprachen lernen muss. Also lerne ich zum Beispiel Python und teile dem Computer die Botschaft $print(2 + 5)$ mit. Ich habe nun, nach Wittgenstein die Bedeutung dieses Ausdrucks durch Beispiele im Gebrauch gelernt.  \\
Wie findet der Computer nun aber heraus, was ich mit dieser Nachricht meine? Er benutzt seinen Compiler. Er übersetzt meine komplexe Aussage in simple Speichermanipulationen. Ist alles berechnet, so wird die Antwort $7$ gegeben. Habe ich gerade ein Gespräch mit meinem Computer geführt?

\subsection{Zwei Konzepte der Bedeutung}
Die grösste Hürde, die wir bei diesem Vergleich überwinden müssen, ist die Folgende: Ist das Verständnis des Computers über die Programmiersprache, vergleichbar mit dem menschlichen Verständnis einer menschlichen Sprache? Denn übersetzt der Computer mithilfe seines Compilers, während der Mensch, gemäss Wittgenstein, durch den Gebrauch die Bedeutung erkennt. So müssen wir diese beiden Konzepte, der Compiler und das menschliche Sprachverständnis, gleichsetzen.

\subsection{Wie ein Computer eine natürliche Sprache verstehen kann}
\subsubsection{Der Turing Test}
Ein möglicher Ansatz ist es, auf eine Weise die Berechnungen des Computers auf das Niveau menschlicher Gedanken hochzuheben. Kann eine Maschine denn denken? Turing hat sich diese Frage auch selbst gestellt, doch war sich auch der Probleme dieser Fragestellung bewusst. Denn könne man die Begriffe \enquote{Maschine} und \enquote{denken} so umformulieren, dass man Maschinen auf ewig aus der Fähigkeit Gedanken zu besitzen ausschliesst.\\
\\
Als Alternative beschreibt er das heutzutage weltberühmte \enquote{Imitation Game}:
Drei Personen in voneinander abgetrennten Räumen. Der Befrager (C) versucht herauszufinden wer ein Mann (X) und wer eine Frau (Y) ist. So müssen die beiden Spieler den Befrager davon überzeugen, dass sie X sind. Nach der Befragung muss C eine der folgenden Aussagen machen, entweder \enquote{A ist Y} oder \enquote{B ist Y}. Was passiert nun wenn man A mit einem Computer, X mit Maschine und Y mit Mensch ersetzt? Der Befrager muss nun Mensch und Maschine voneinander unterscheiden.\footnote{Turing 1950, 3.1} \\

\subsubsection{Ein Compiler für die menschliche Sprache}
Wenn eine Maschine nun diesen Test besteht, schliesst Turing, kann die Maschine denken. Natürlich wäre das Sprachverständnis hier einbegriffen, was man an der Art des Testes klar erkennen kann. Die Aussage ist nun diese: Wenn Computer in der Lage sind menschliche Sprache auf dem gleichen Niveau wie Menschen verwenden können, ist ihr Verständnis davon auch das Gleiche. Und Dieses Verständnis wird schlussendlich auch von einem Computerprogramm gesteuert. Ist das dann ein Compiler für die menschliche Sprache? \\
Also ist das Verarbeiten von Programmiersprachen auf Seiten eines Turing-Test-bestehenden Computers nicht davon zu unterscheiden von dem \enquote{Verständnis} einer natürlichen Sprache. \\
\begin{displayquote}

\subsubsection{Sprachen als Städte}
\enquote{
Unsere Sprache kann man ansehen als eine alte Stadt: Ein Gewinkel von Gässchen und Plätzen, alten und neuen Häusern, und Häusern mit Zubauten aus verschiedenen Zeiten, und dies umgeben von einer Menge neuer Vororte mit geraden und regelmässigen Strassen und einförmigen Häusern. (PU: §18)
}
\end{displayquote}
Erweitern wir diese Metapher, so stellen wir uns einen Roboter vor, welcher in der Lage wäre diese Stadt zu navigieren. Nun lässt man einem Menschen des Roboters Pfad betrachten und jener könne des Roboters Pfad nicht von einem menschlichen unterscheiden.  \\
Jetzt stellen wir uns eine (künstliche) Programmiersprache als neue Stadt vor. Ein klar geordnetes Raster an regelmässigen Strassen und einförmigen Häusern. So ist die Stadt dafür konzipiert, dass ein Roboter sich darin zurechtfindet. Zwischen der neuen Stadt und der alten Stadt gibt es keinen kategorischen Unterschied. Zwar wurde eine nach System errichtet und die andere natürlich entstanden, doch fährt der Roboter durch beide auf die gleiche Weise: Mit seinem Compiler als Stadtplan.

\subsubsection{Das Sprachverständnis heutiger Programme}
Diese Aussagen bewegen sich natürlich noch in einem hypothetischem Raum. Gibt es ein Computerprogramm, welches den Turing Test besteht? Der Chatting-Bot Cleverbot soll in der Lage sein menschliche Konversationen zu halten. So wurde er zu 59.3\% als Mensch eingestuft. Seine menschlichen Gegenstücke schafften 63.3 \%.\footnote{Cleverbot 2019}. Ein neueres Beispiel wäre das Sprachmodell GPT-2. Konzipiert um die menschliche Sprache zu verstehen, ist es eines der besten Kandidaten ein \enquote{humanes Programm} genannt zu werden.\footnote{Radford 2019, §3, ob GPT-2 wirklich einen Turing-Test bestehen könnte ist schwer zu beantworten, denn wurde es nicht zur Konversation konzipiert. Es erbrachte jedoch ausserordentliche Ergebnisse in einer Bandbreite an standardisierten Messmethoden.} \\
Was ist das Geheimnis dieser Wundermaschinen? Wie beherrschen sie komplexe Grammatik? Cleverbot als auch GPT-2 setzen dabei auf Imitation. Cleverbot sucht durch seinen Katalog an menschlichen Antworten. Frage ich es zum Beispiel \enquote{Was ist die Hauptstadt von Frankreich?} wird Cleverbot eine Antwort geben, welche es selbst von einem vorherigen Konversationspartner bekommen hat.\footnote{Aron 2011} GPT-2 benutzt hierbei ein fortgeschritteneres System: Ein sogennantes \enquote{Transformer} Neural Network.\footnote{Radford 2019, Abstract}. Das ganze basiert auf einem Selbstlernenden Algorhitmus\footnote{Extreme Vereinfachung}, welchen man mit Sprachmaterial füttert. Dieses bestand aus 40 Gigabyte an extrahiertem Text aus Websiten.\footnote{Radford 2019, §2.1} Was wird also gelernt um die Bedeutung zu verstehen? Der Gebrauch.

\subsubsection{Übereinstimmung mit Wittgenstein}
Gibt es einen Compiler für die menschliche Sprache, so ist der Turing Test ein guter Ansatz für dessen Bewertung. Die fortgeschrittensten Programme in der Sprachimitation, basieren hierbei jedoch nicht auf einer feste Logik, sondern lernen durch Beispiele im Gebrauch der verschiedenen Worte. Das stimmt nahezu perfekt mit Wittgensteins Aussage über Bedeutung der Sprache überein. \\

\subsection{Kritik am Sprachverständnis von Computer}
\subsubsection{Die Erfindung des Turing Test}
\begin{displayquote}
\enquote{At the very dawn of the computer age, Alan Turing confronted a cacophony of
mostly misguided debate about whether computer scientists could ever build a
machine that could really think. Very sensibly he tried to impose some order on the
debate by devising what he thought would be a conversation-stopper: he described
a simple operational test that would surely satisfy the skeptics: anything that could
pass this test would be a thinker for sure, wouldn’t it?}\footnote{Epstein 2008, vii} \footnote{Deutsche Übersetzung: In den frühsten Jahren der Informatik versuchte Alan Turing die zumeist völlig falschen Debatten darüber, ob Wissenschaftler jemals einen denkenden Computer bauen könnten, aufzulösen. Sehr rational versuchte er die derzeitigen Debatten zu ordnen, indem er einen Konversationsstopper einführte. ER beschrieb einen simplen Test, welcher auch die Skeptiker nicht unterschlagen könnten: Alles was den Test besteht, könne denken, ganz sicher, oder?}
\end{displayquote}
Die allgemeine Gültigkeit des Turing Tests ist umstrittener denn  je. Er wurde eingeführt, als die Computerwissenschaft noch in ihren Babyjahren war. Ob dieser denn in unserer heutigen Welt der KI noch zu gebrauchen sei. So habe Turing gar das Denken von Maschinen \enquote{im menschlichen Sinne} ausgeschlossen, sondern nur die Möglichkeit einer Maschine ein Gespräch zu führen beschrieben.\footnote{Selzer, 2011, 3} \\
So war seine Aussage nie eine wissenschaftliche These sondern nur eine subjektive Aussage.

\subsubsection{Die chinesische Box}
Zwar scheint die Art wie Programme lernen Wittgensteins Sprachphilosophie zu reflektieren, odch schlussendlich werden all diese Beispiele auf eine Logik hinunter gebrochen, sonst könne ein Computer diese gar nicht speichern und ausführen. Wenn wir uns zurück zur Turing-Maschine entsinnen, so sieht man, dass alles was ein Computer tut irgendwann als einfache Speichermanipulation dasteht. So gibt es eine Speichermanipulation die z.B. genau mit dem Ausdruck \enquote{Was ist die Definition von Ehre?} übereinstimmt. Ist es also doch möglich die menschliche Sprache in simple Axiome hinunterzubrechen? \\
Man stelle sich eine kleine Box mit einem Menschen vor. Dieser erhält von Wissenschaftlern von aussen zwei Blätter Papier. Auf dem ersten stehen mehrere Fragen auf chinesisch (Input). Die Person kann hierbei kein chinesisch und ist somit nicht in der Lage die Fragen zu beanworten. Auf dem zweiten Papier steht nun eine Anleitung: So hat die Person für jede Kombination an Schriftzeichen eine genaue Antwort, die sie geben soll.\footnote{Searle 1980: 3, leicht abgeändert} Nennen wir dieses Blatt Papier \enquote{den Compiler für Chinesisch}. Mit der Anleiung schreibt die Person nun ihre Antworten auf ein seperates Blatt Papier und reicht dieses zurück nach aussen (Output). Die Wissenschaftler wären begeistert, so sind sie sich sicher, dass die Person in der Box nun Chinesisch kann. So seien die Antworten verglichen mit muttersprachigen Chinesen nicht zu unterscheiden. \\
Die Grundauffassung Vieler ist nun, dass die Person in der Box einfach nur die Schriftzeichen auf der Anleitung kopiert, aber gar kein Verständnis für die Sprache hat. Diese Antwort ändert sich nicht, egal wie komplex die Anleitung ist und für wie viele spezifische Fälle eingeplant worden ist. Also gibt es, solange man diesem Gedankenexperiment folgt, keinen \enquote{Compiler für Chinesisch} so ist jedes Folgen strikter Logik kein wirkliches Verstehen. Nicht nur behält Wittgenstein Recht, sondern \enquote{verstehen} die derzeitigen Programme (Cleverbot und GPT-2) natürliche Sprachen im menschlichen Sinne gar nicht. Zerfällt hier nicht der Vergleich zwischen natürlicher Sprache und Programmiersprache, so ist eine Programmiersprache immer durch ein Compiler definiert?

\subsection{Die menschliche Maschine}
\subsubsection{Einführung in Behaviorismus}
Die Frage wie und ob Menschen überhaupt denken ist eine umstrittene in der Philosophie. \enquote{Behaviorismus} bezieht in dieser Debatte die folgende Position:
\begin{displayquote}
\enquote{What it is to be in a certain state of mind is to be disposed to behave in
a certain way.}\footnote{Stout (2006), 3} \footnote{Deutsche Übersetzung: Einen gewissen Gemütszustand zu verspüren ist nichts anderes, als auf eine gewisse Weise zu handeln.} \footnote{Es gibt verschiedene Versionen des Behaviorismus, genau wie es verschiedene Arten des Skeptizismus gibt. Ich beziehe mich hier auf eine neuere akademische Version (siehe Quelle).}
\end{displayquote}
Vertreter von Behaviorismus denken also, dass Gemütszustände auf gar keine andere Weise existieren, als was sie den Organismus dazu bringen zu tun.\footnote{Stout (2006), 3} Das bedeutet aber nicht, dass Behavioristen innere Vorgänge vollkommen abstreiten. So stimmen sie zu, dass ein Mensch durch die inneren chemischen Reaktionen zwischen Neuronen gesteuert wird. \footnote{Stout (2006), 4}\\
Würde man nun aber einen Roboter R bauen, welcher exakt dieselbe Reaktion auf jeglichen Reiz wie Person P hat, so würde ein Behaviorist aussagen, dass Roboter R und Mensch P den exakt selben Gemütszustand besitzen. Der Fakt, dass Roboter R durch einen hochkomplexen Algorithmus und Person P durch ihr Hirn gesteuert wurden, wird also irrelevant.

\subsubsection{Gegenüberstellung von Behaviorismus und der chinesischen Box}
Bezieht man nun einen behavioristischen Blickwinkel auf das Gedankenexperiment auf die chinesische Box, verändern sich gewisse Dinge fundamental. Wir stellen zwei chinesische Boxen nebeneinander: Eine davon enthält einen Muttersprachler M, in der anderen befindet sich K, der kein Chinesisch versteht. Nun werden beiden die gleichen Fragen auf Chinesisch gestellt. So geben nun beide auf jegliche mögliche Frage die exakt selbe Antwort. Für den Behavioristen würde es keine Rolle spielen, dass Person M die chinesische Sprache M versteht, während K nur einer Anleitung folgt. Beide Boxen hätten denselben Gemütszustand. \\
Das ist durchaus mit dem Motto von \enquote{Gebrauch ist Bedeutung} zu vereinbaren, schliesslich kümmert sich der Gebrauch nicht um innere Vorgänge.

\subsubsection{Regeln für das Gehirn}
Man kann das Hirn eines Muttersprachlers selbst als eine chinesische Box sehen. Die \enquote{Fragen}, die man dem Gehirn stellt, wären dabei einfach die verschiedenen Reize aus der Umwelt. Und die \enquote{Antworten} des Hirnes sind die verschiedenen Nervensignale, welches an die Muskeln im Körper sendet. In diesem Gehirn muss sich irgendwo das Sprachverständnis für Chinesisch verstecken. \\
Ein Behaviorist würde nun sagen, dass es in dem Hirn eine gewisse Anordnung von Teilchen gibt, welche auf das Hören einer Frage eine physikalische Reaktion auslöst, deren Endeffekt die Antwort auf die Frage ist. Diese Anordnung von Teilchen kann man funktional als den \enquote{Compiler für Chinesisch} verstehen. Also ist das Herunterbrechen der natürlichen Sprache in Grundregeln doch möglich, denn muss ihr Zustand ja irgendwie in dieser Anordnung von Teilchen gespeichert sein.

\subsection{Kritik an der behavioristischen Ansicht}
\blindtext[1]

\section{Gedanken über den Gebrauch und Möglichkeiten von Programmiersprachen und natürlichen Sprachen}

\subsection{Die Flexibilität von Programmiersprachen}
\subsubsection{Das Definieren von neuen Funktionen}
Fast jede Programmiersprache bietet die Möglichkeit neue Funktionen zu definieren. Diese sind sozusagen Kurzfassungen komplizierter Operationen. Vergleichbar ist das mit mathematischen Funktionen: So ist zum Beispiel die Funktion $f(x) = \frac{(x^2 + 2)}{x}$ eine Kurzfassung mehrerer Operationen hintereinander. Will ich diese Funktion zum Beispiel in einer Rechnung mehrmals anwenden, so kann ich einfach $f(2) + f(3) - f(4)$ schreiben. \\
Die Gemeinsamkeiten mit einem Compiler sind nicht zu übersehen. Doch muss man hier klar unterscheiden: Ein Compiler übersetzt von einer Sprache in eine andere, eine Funktion übersetzt von einer Sprache in dieselbe. Ich kann meine Rechnung genauso gut als $\frac{(2^2 + 2)}{2} + \frac{(3^2 + 2)}{3} - \frac{(4^2 + 2)}{4}$ schreiben. So muss ich aber viel Information mehrmals hinschreiben, weshalb man eben diese Kurzfassung definiert. \\
Die Parallele zu einer Funktion ist ein neues Wort. Halte ich zum Beispiel ein Referat über eine neu-gefundene Krankheit, erkläre ich deren Namen als \enquote{Entquillis}. Erwähne ich den Namen \enquote{Entquillis} in einem anderen Kontext, so können sich die Zuschauer \enquote{die neu-gefundene Krankheit} denken und ich muss mich nicht jedes Mal wiederholen. \\

\subsubsection{Libraries und Sprachspiele}
Viele Programmiersprachen bündeln mehrere Funktionen zusammen. Dies ist eine sogennante \enquote{Library}.\footnote{Deutsch: Bibliothek, der deutsche Begriff ist jedoch kaum in Gebrauch, weshalb ich \enquote{Library} verwende}. Python kommt mit einer Vielzahl an eingebauter Libraries, eine davon ist die sogennante \enquote{Math}. Math ist auf mathematische Operationen spezialisiert. Will ich also zum Beispiel die Quadratwurzel einer Zahl, schreibe ich folgendes:
$$import \hspace{1mm} math$$
$$math.sqrt(36)$$
Die erste Linie erklärt dem Compiler, dass ich die Math Library verwenden will. Es ist sozusagen ein \enquote{Ich will über Mathematik sprechen}. \\
Die Zweite Linie wendet die Funktion an. \enquote{In der Mathematik nimm die Quadratwurzel der Zahl 36.} \\
Jetzt sieht man wie die Math Library mit dem Sprachspiel nach Wittgenstein übereinstimmt.

\subsubsection{Was war zuerst, die Definition oder der Gebrauch?}
Die Übereinstimmung ist nicht sofort ersichtlich: Denn ist für Wittgenstein ein Sprachspiel durch den Gebrauch definiert, während die Libraries ihre Funktionen unabhängig von deren Gebrauch besitzen. Oder zumindest scheinen sie unabhängig vom Gebrauch, bis man bedenkt, dass eine Funktion noch immer von einer Person geschrieben werden muss. Diese Person will die Funktion für eine Kurzfassung verschiedener Rechnungschritte \textbf{gebrauch}en. Ohne die Absicht des Gebrauches ist eine Funktion nutzlos. \\

\subsubsection{Bedeutung ist Demokratie}
Libraries sind oft nicht eine private Sache.\footnote{Eine Diskussion privater Libraries und Wittgensteins Diskussion über Privatsprachen wäre hier möglich.} Die Math Library ist weltweit im Gebrauch, denn ist sie als eingebaute Library in jeder Version von Python inbegriffen und wird von der Python Software Foundation verwaltet. \\
Wie kann man denn nun ein Kulturgut wie die natürliche Sprache mit einer wohlkurierter Sammlung an Instruktionen vergleichen? Welches Wort in einer natürlichen Sprache was bedeutet, ist eine Sache der Allgemeinheit, während Python und somit auch die Math Library einen klaren Autor besitzen. Nur dieser kann also die Sprache verändern. \\
\\
Diese Auffassung zieht jedoch nicht in Betracht unter welcher Lizenz Python steht. Dessen GPL-Lizenz\footnote{Python Software Foundation 2019} erlaubt nämlich Veränderungen und auch Veröffentlichung dieser Veränderungen.\footnote{GNU 2019} Dies bedeutet, das mir nichts im Weg steht, meine eigene Version von Python namens \enquote{Pythan} zu veröffentlichen. Niemand besitzt ein absolutes Monopol über Python. \\
\\
Die Rolle der Python Software Foundation kann man mit derjenigen der Académie française vergleichen. Sie sind ein höchst respektierte Autorität und haben dadurch einen grossen Einfluss auf die Sprache.\footnote{Lebars 1913, 89} Doch basiert diese Autorität nicht auf einer Kontrolle, sondern besteht sie nur, da eine grosse Anzahl Benutzer der Sprache, die Python Software Foundation beziehungsweise die Académie française respektieren. \\
\\
Ausgesprochen grösser ist der Einfluss, welchen die Allgemeine Verwendung eines Begriffs und somit dessen Bedeutung auf die Sprachautoritäten hat. Als zum Beispiel 2015 der Oxford Dictionary das Verb \enquote{twerk} aufnahm, tat er dies, weil das Wort grosse gesellschaftliche Relevanz besass.\footnote{20 Minuten 2015} \footnote{Oxford Dictionary 2015} Im gleichen Jahr fügte die Python Software Foundation die \enquote{async/await} Syntax ein, welche in den letzten Jahren zu einem fundamentalen Teil von vielen Applikationen wurde.\footnote{Robinson 2015} Dies war nur eine Reaktion auf die vielen inoffiziellen Libraries, welche die \enquote{async/await} schon eingeführt hatten. \\
Sprachautoritäten bestimmen die Bedeutung nicht direkt, doch beeinflussen sie den Gebrauch.

\section{Ein Blick in die Zukunft: Natürliche Sprachen als Programmiersprachen}
\blindtext[1]


\section{Konklusion}
\blindtext[1]

\section*{Literaturverzeichnis}
\textbf{Aho, Alfred V.; Monica S. Lam; Ravi Sethi et al. (2007)}: \textit{Compilers: \\ principles, techniques, \& tools.} Boston: Pearson Addison-Wesley \\
\textbf{Aron, Jacob (2011}: \textit{Software tricks people into thinking it is human} \\ https://www.newscientist.com/article/dn20865-software-tricks-people-into-thinking-it-is-human/ [21.11.19] \\
\textbf{Cleverbot (2019)}: \textit{\enquote{Cleverbot was judged to be 59.3\% human. [...] The humans in the event achieved just 63.3\% .}} https://www.cleverbot.com/human [21.11.2019] \\
\textbf{Epstein, Robert; Gary Roberts; Grace Beber (2008)}: \textit{Parsing the Turing Test. Philosophical and Methodological Issues in the Quest for the Thinking Computer.} New York City: Springer \\
\textbf{GNU (2019)} \textit{Unter den Aufzählungen: \enquote{the freedom to change the software to suit your needs, the freedom to share the changes you make.}} \\
https://www.gnu.org/licenses/quick-guide-gplv3.html [26.112019] \\
\textbf{Kripke, Saul A. (1982)}: \textit{Wittgenstein on rules and private language: An Elementary Exposition.} Cambridge: Havard University Press. Deutsch: Übersetzt von Helmut Pape (1987): \textit{Wittgenstein über Regeln und Privatsprache. Eine elementare Darstellung.} Frankfurt am Main: Suhrkamp \\
\textbf{Lebars, John (1913)}: \textit{Catholic Encyclopedia} Verfügbar unter: \\ https://en.wikisource.org/wiki/Catholic\_Encyclopedia\_(1913)/French\_Academy \\
\textbf{Oxford Dictionary (2015)}: \textit{Wörterbucheintrag für das Wort "to twerk"} \\ https://www.lexico.com/en/definition/twerk [28.11.2019] \\
\textbf{Newen, Albert; Markus A. Schrenk (2008)}: \textit{Einführung in die Sprachphilosophie.} Darmstadt: WBG \\
\textbf{Petzold, Charles(2008)}: \textit{The Annotated Turing. A guided Tour through Alan Turing’s historic Paper on Computability and the Turing Machine.} Indianapolis: John Wiley \& Sons \\
\textbf{Python Software Foundation (2019a)}: \textit{Unter \enquote{Files} kann man den gesamten Quellcode downloaden.} https://www.python.org/downloads/release/python-380/ [16.11.2019] \\
\textbf{Python Software Foundation (2019b)}: \textit{Das ist das Github Repository für die Python library \enquote{requests}. Nicht nur ist der Quellcode für alle sichtbar, doch kann man Veränderungen (sogennante \enquote{Push-requests}) einsenden.} https://github.com/psf/requests [26.11.2019] \\
\textbf{Python Software Foundation (2019c)}: \textit{In der Tabelle wird erwähnt, dass alle Python Versionen nach 2.2 mit der GPT Lizenz kompatibel sind.} https://docs.python.org/3/license.html [26.11.2019] \\
\textbf{Searle, John R. (1980)}: \textit{Minds, Brains, and programs.} Cambridge: Cambridge University Press \\ Verfügbar unter: http://cogprints.org/7150/1/10.1.1.83.5248.pdf [21.11.19]
\textbf{Radford, Alec; Jeffrey Wu; Rewon Child et al. (2019)} \textit{Language Models are Unsupervised Multitask Learners} Verfügbar unter: \\ https://d4mucfpksywv.cloudfront.net/better-language-models/language-models.pdf [21.11.2019] \\
\textbf{Robinson, Scott (2015)}: \textit{\enquote{Asynchronous programming has been gaining a lot of traction in the past few years, and for good reason.}} \\
https://stackabuse.com/python-async-await-tutorial/ [28.11.2019] \\
\textbf{Selzer, Edgard (2011)}: \textit{Denn der Mensch ist mehr als nur ein Computer. Warum die Turing-Maschine das WITTGENSTEIN'sche Sprachspiel nicht bewältigen kann.} Wien: Trauner \\
\textbf{Stephens, D. Ryan; Christopher Diggins; Jonathan Turkanis et al. (2006)}: \textit{C++ Cookbook.} : Sebastopol: O'Reilly Media \\
\textbf{Stout, Rowland (2006)}: \textit{The Inner Life of a Rational Agent. In Defence of Philosophical Behaviourism.} Edinburgh: Edinburgh University Press Ltd \\
\textbf{Turing, Alan (1937)}: \textit{On Computable Numbers, with an Application to the Entscheidungsproblem.} in: \textit{Proceedings of the London Mathematical Society. Band 42.} Cambridge: Cambridge University Press \\
\textbf{Turing, Alan (1950)}: \textit{Computing Machinery and Intelligence} in: \textit{Epstein, Robert; Gary Roberts; Grace Beber (2008): Parsing the Turing Test. Philosophical and Methodological Issues in the Quest for the Thinking Computer.} New York City: Springer \\
\textbf{Wittgenstein, Ludwig (1921)}: \textit{Tractatus Logico-Philosophicus.} in: \textit{L. Wittgenstein (1984): Werkausgabe in 8 Bänden. Band 1.} Frankfurt am Main: Suhrkamp \\
\textbf{Wittgenstein Ludwig (1953)}: \textit{Philosophische Untersuchungen.} in: \textit{L. Wittgenstein (1984): Werkausgabe in 8 Bänden. Band 1.} Frankfurt am Main: Suhrkamp \\
\textbf{Wittgenstein Ludwig (1956)}: \textit{Bemerkungen über die Grundlagen der Mathematik.} in: \textit{L. Wittgenstein (1984): Werkausgabe in 8 Bänden. Band 6.} Frankfurt am Main: Suhrkamp \\
\textbf{20 Minuten (2015)}: \textit{«Twerken» steht jetzt offiziell im Wörterbuch. Herausgegeben am 16.6.2015. Autor nicht erwähnt.} Verfügbar unter: \\ https://www.20min.ch/wissen/news/story/-Twerken--steht-jetzt-offiziell-im-Woerterbuch-24505065  [28.11.2019] \\




\end{document}